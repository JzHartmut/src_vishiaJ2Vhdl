= Java logic description - Approaches ( to VHDL)
:toc:
:toclevels: 4
:sectnums:
:sectlinks:
:max-width: 52em
:prewrap!:
:cpp: C++
:cp: C/++
:wildcard: *
:stylesheet: my.css


See also:

link:Java2Vhdl_StyleGuide.html[] How to work with Java for Fpga logic

link:VhdlConv.html[] internal docu how does it work

link:../../../spe/html/SpeA-FPGA/SpeA-JavaFPGA.html[] This is the description of a FPGA design for SinglePairEthernet PHY layer. Work in progress.

link:../../../spe/html/SpeA-FPGA/SpeA-FPGA.html[] The older description based on only VHDL and Aldec-HDL simulation tool using.
Comparing both descriptions you can also see advantages in the documentation of the behavior of the FPGA.

This is a preliminary information. The tool Java2Vhdl translator is in progress.

== Motivation

VHDL was originally created in the 1980^th^ for timing simulations of the behavior of ASICs
See link:https://en.wikipedia.org/wiki/VHDL[]:
__In 1983, VHDL was originally developed at the behest of the U.S. Department of Defense 
in order to document the behavior of the ASICs that supplier companies were including in equipment.__

As a second approach it was later used to determine the content of FPGAs (input for routing).

In the earlier time of FPGA development, till mid of 1990^th^, usual the timing behavior
was evaluated after the routing process, either by timing simulation, or by examination all delays of paths.
With some manually settings (placing, special lines manually routed) the routing is repeated 
till all is met. For that also the VHDL was proper. 

From approximately mid of 1990^th^ usage of "__timing constraints__" become more importance. 
With timing constraints the router can decide by itself for using routing resources. 
It means constrains + logical description is sufficient to get a proper FPGA content.
The importance of timing simulation is no longer given, at least for most of the FPGA content. 
Only for clock synchronization approaches or asynchronous parts of logic it is necessary.  

The FPGA tool suites support the formulation of timing constraints usual in a special kind.
VHDL has not an meaningful contribution for that. 

Also the simulation of hardware designs needs often special tools. 
Test approaches with comprehensive functional tests are a special topic. 

For all that reasons another way to formulate 
hardware design content inclusively timing constraints were searched.

This article offers the idea to formulate hardware design with timing constraints
and elaborately possible functional tests, in Java language.
The design is oriented to a __one clock system__ as synchronous state machines. 
The source code which describes that and which is used for the functional tests
is then translated to VHDL for the routing process. 
It means, the full FPGA content can be developed with functional simulation outside of FPGA tool suites. 
From the FPGA tools so much as necessary can be used,
for example only the routine process with timing report (to check whether all is met),
or for example also a timing simulation for specific signals outside the functional logic
(synchronization with more as one clock or such one). 
That is all possible of course, but firstly the synchronous part of the design 
can be planned and tested completely only using a Java development environment (such as Eclipse). 
This supports also elaborately usage of test possibilities (input signal preparation, evaluation, test control etc.).


== Why Java and not another language

Java is one of the most known and used programming languages. 
In opposite to for example {cpp} Java is a save language. 
The commonly small programming mistakes by the users do not cause a complicated behavior,
they are obviously. 

Java knows the `final` keyword, which is proper to formulate assignments in a unique kind. 
That is one of the benefits of the language itself. 
The `const` keyword in C/{cpp} cannot fulfill the same.

A second benefit is the possibility of formulate annotations, which are recognized also in the run time environment, 
not only for translation. 

See the examples and patterns. 

<<<
== Writing hardware logic in Java

There are two different approaches for Fpga content:

* a) Pure hardware logic
* b) Using FPGA as platform instead a microcontroller: 
A microcontroller can react in step times down to ~ 10 µs. 50 µs are often usual.
For faster especially controlling algorithm with step times of ~ 1 µs the usage of FPGAs becomes more and more familiar,
because the FPGA have enough space, are no more so expensive with much space and the tool suites are more and more proper.

The approach b) is not handled here. They are other approaches such as link:https://hdl.github.io/awesome/items/synthesijer/[]
or programming FPGA in {cpp} (known since ~ 2005) which fulfill this approaches.

This work is related to pure hardware logic.

Writing hardware logic in Java requires knowledge about hardware in FPGA. 
On the first hand should both familiar with the internal structures of logic blocks in your FPGA. 
Also which such thinks as floorplanner, physical view, timing reports.
On the other hand you should familiar with VHDL as hardware description. 
The VHDL is used as bridge between the Java hardware sources and the place&route tools of the FPGA. 

The benefit of writing hardware logic in Java is: Also with a simple tool chain for VHDL and FPGA
you can do elaborately tests. The modularity is better supported. 
Java has a proper software technology (ObjectOrientation, is used also for hardware). 
Java is often proper known from a large spread of persons. The tool support is well.
That are detail advantages.


[#BasicFuncSim]
=== Principle of functional simulation of synchronous state machines

Typically, the bulk of the content of an FPGA should be a synchronous design. 
It means, all input signals are gathered by only one clock, and then furthermore used only clock-synchronous. 

All new states are based on the given states with logical relations, 
which are then adopted as current states with the clock edge.   

image:../../img/Fpga/SimpleSynchrLogic.png[Simple synchron logic, float="right"]

Q~n+1~ = fn( Q~n~)

Whereby the input signals are also part of the Q (means all FlipFlop states). 
The fn (function) is a logical relation.

The time to build the logical output from given inputs should be lesser than the time between the clock edges.
Then the logical functionality is also the real functionality. 

If delays are longer, the behavior is undefined. 
That is not admissible. It is controlled by the timing constraints. 


But not all paths should consider the minimal time between the clock edges. 
For example you can have a fast clock signal of 200 MHz (5 ns). Some paths should switch in this speed.
But not all paths can met the constraint of 5 ns. 
If the logic is complex, it is a too much requirement.
Usage of different clocks for different logic parts is really not a good idea, 
it requires additional effort for synchronization between the systems. 
There is a better solution.  

image:../../img/Fpga/CESynchrLogic.png[synchron logic with CE, float="right"]

Usual the FlipFlops in the Logic Block of a FPGA have a CE input. It is __Clock Enable__. 
If this in input is 0, then the signal on the D input has no effect.
The FF does not change its state. 
It means, you can free a FF for switching with a longer period though the clock frequency is high.
Only the CE signal should be provided in the required speed for the clock period. 
The other signals to build the logic need only the CE period. 

image:../../img/Fpga/CE_Scope.png[Scope CE signal and delay]

You see the clock in the last track, each rising edge changes the FF state.
But the CE signal controls that only each 5^th^ clock edge force switch. 
In this example the CE is built by a counter which outputs CE exactly after each 5^th^ clock edge.
But you see also that CE is delayed. It does not come immediately after the rising clock edge, 
it does come a little bit later and goes later. 
The importance is, that CE should be stable on the rising clock, 
with a minimal necessary setup time. CE can also be delayed, but lesser as one clock period.

In this example the red signal in the first track switches after any rising clock edge,
not guarded with CE. But the green signal switches with clock and CE.
The next track shows a long delayed signal. It is presented here as ramp,
because for simulation Simulink ((C) Mathworks) is used (not VHDL and a FPGA tool suite).
But before the next CE clock edge, the signal arrives its necessary state, and that is sufficient. 
So the next CE-enabled clock edge gets the state of the delayed signal without failure
and produces the next dark green output. 
This output can also in turn have a delay to its next output, feeding the D input of a FF etc. pp.  

In VHDL such behavior can be written in the following form:

----
PROCESS(CLK, CE) BEGIN
  IF rising_edge(CLK) THEN
    IF CE='1' THEN
      Q2 <= Q1 AND someOtherLogic;
    END IF;
  END IF;
END PROCESS       
----

In VHDL it is determined that nothing should be done if `CE` is not `='1'`. 

As ideal case `CE` is an output of a FlipFlop. 
This output is immediately routed to the CE input of all using FF. 
For routing a stable clock net with high fan out is used. 

But the router decides by itself how the CE input of the FF in the FPGA are used. 
See the next slightly changed example:

----
PROCESS(CLK, CE) BEGIN
  IF rising_edge(CLK) THEN
    IF CE='1' THEN
      IF(steadyState='1') THEN
        Q2 <= Q1 AND someOtherLogic;
      END IF;  
    END IF;
  END IF;
END PROCESS       
----

There is another signal as `IF` condition, here named as `steadyState`. 
Then the routing process can integrate this signal also to build the CE for the FF inputs.
For example if you have a register of 16 or more FF instead the single Q2 and Q1, 
it saves a lot of routing ressources to do so. 

image:../../img/Fpga/CEsteadySynchrLogic.png[synchron logic with CE, align="right"]

Above you see which may be produced by the router, drawn with ordinary gatter logic.
In the real FPGA LUTs (Look Up Tables) are used instead gatter, of course. 


[#BasicTiming]
=== Timing constraints for CE and steadyState

Because the CE is built fastly which each clock edge, it should have a less delay. 
All FF which should have such an fast delay can be assembled to a FF group, 
and for that group a constraint can be written (here for Lattice Diamond FPGA tool):

 MAXDELAY FROM GROUP "FFfast" 4.5 ns;

But maybe that the `steadyState` signal does not switch frequently. 
It switches only  also with the CE signal as shown in the schema above. 
Then it can have a longer delay because the fast switching CE signal itself 
determines the used `CE1` for CE. 
It means the FF for `steadyState` may be a member of the group for CE-driven FF 
and can be have a longer delay:

 MAXDELAY FROM GROUP "FF_CE" 23.0 ns;
   
Now the router can use a longer path for the `steadyState` signal
to build a CE signal for other FF. 
The longer delay is possible because this signal does not switch independent,
it switches only with `CE` itself.

It is not expected that the logic for the `CE1` with the longer delayed signal `steadyState`
or some more other signals produces hazards or glitches because the `CE` itself is also used
and it has the short delay. It determines the output of the LUT to build the `CE1` to 0
so long `CE='0'`. 

=== Be careful because of glitches in logic

But you should take care that really one signal with a short path is always member of such an `IF` construct.
If you write in VHDL

----
PROCESS(CLK, CE) BEGIN
  IF rising_edge(CLK) THEN
    IF (signal1 XOR signal2)='1' THEN
      Q2 <= Q1 AND someOtherLogic;
    END IF;  
  END IF;
END PROCESS       
----
 
then the router can built a CE to control switching the FF Q2 too. 
If the `signal1` and `signal2` constrain a longer delay as the clock period
then it is possible that a faulty intermediate state can occur 
where the signals are detected as different (XOR delivers '1') 
though the signals are not different after the delay. 
Then the CE can be '1' by mistake during a clock edge.
It means this is a bad formulation in VHDL. 
At least one fast signal should be used as AND logic.

image:../../img/Fpga/CE_Glitch_scope.png[]

Only for info: In Simulink this is produced by the following schema:

image:../../img/Fpga/CE_Glitch_sch.png[]

The TimeSignals S-Function-Block is programmed with the given input pattern:

----
%time:0.000000000: LogicInput.signal1 = 0, LogicInput.signal2 = 0;
%time:0.000000050: LogicInput.signal1 = 0, LogicInput.signal2 = 0;
%time:0.000000100: LogicInput.signal1 => 1.0;
%time:0.000000080: LogicInput.signal2 => 1.0;
----

See also link:../../../smlk/html/SmlkTimeSignals/SmlkTimeSignals.html[smlk/.../SmlkTimeSignals.html].

The signals itself are float with ramps, they are converted by the comparison block to boolean,
with that approach a delay can be simulated.
Because the first `signal1` reaches the 1-level earlier than the `signal2`,
temporary the '1' value is built by the XOR. That is a glitch. 
If the clock edge comes during the glitch, it is effective and causes a faulty behavior. 

Note that the Simulink is *not* used for FPGA design for this example.
It is only used to get simulation results of this hardware. 
I have used Simulink because it is my familiar simulation environment not only for FPGA,
but more for controlling approaches. 
It should be possible for everybody to use him/here likely tool to get results. 
The results should be comparable and transferable between the tools.

**Automatic check on Java level**

The above shown situation can come also from a Java formulated design.
It should be possible to check such constructs statically on Java level, yet not clarified.
The check should test whether at least one signal is in AND constellation for the whole condition, 
and this signal should have the less constrain for delay.


=== Data types in Java for Fpga design in VHDL

* VHDL distinguishes between the `BIT` type which has two states '1' and '0' (similar as boolean in Java)
and adequate also for the `STD_LOGIC` type which may have also only the both values '1' and '0' if no more is used
on the one hand ...
* And on the other hand VHDL knows a boolean type which is stronly used in `IF THEN` statements. 

There is no automatic conversion between both. 

The typical boolean operators AND, OR are valid for all three, the boolean type and also for `BIT` and `STD_LOGIC`
but of course with different results. The result follows the inputs, a mix is not possible. 
This may be one of the "__safety__" of the VHDL language, strongly distinguish, but it can be seen also as difficult and confusing. 

In Java the situation is clarified with a boolean type which is also strongly and safe:

* `boolean` in Java has two states, `true` and `false`. 
* Better than in C language the `true` representation is strongly defined. 
* More strongly as in C and {cpp} language a `if` statement needs a `boolean` expression. All other is faulty.

For the Java representation of a Fpga design with view to VHDL the following is defined:

* A `boolean` variable represents a `SIGNAL` of `BIT` type. 
The values `true` and `false` are associated to `1` and `0`. 
__Negative logic__ is not supported as language feature. It is a feature of the user's semantic. 

* A `BIT_VECTOR` is represented by a `int` or `long` value (with up to 64 bit). 
This is better to test in Java as a boolean vector, because `BIT VECTOR` is often used as register values, 
also for shift and compare operations. 

* To access one bit of such an vector, there is a special access operation
`Fpga.getBit(vector, 7)` where `7` is a bit number. 
The result of this operation in Java is `boolean` which is a `BIT` type.
* Exact the same can be done with a `STD_LOGIC_VECTOR`, also represented in Java with `int` or `long`,
distinguished only by the annotation `@Fpga.BITVECTOR` or `@Fpga.STDVECTOR` 

* Yet numerical values are not supported, done in the (near) future. 
The types `short` and `int` for 16 and 32 bit bit width without additional annotations should be used
for 16- and 32 bit with algorithm (`long` also for 64 bit). 


[#boolIf]
=== boolean expression and SIGNAL types with view to VHDL

In VHDL, if you have a boolean operation with a `BIT` or also `STD_LOGIC` type, you can write:

 result <= (a AND NOT b) OR c;
 
If you do the same for an `IF` construct you must write:

 IF (a='1' AND b='0') OR c='1' THEN
 
It means the operands should fistly converted to a boolean one. 
But it is also possible to write:

  IF ((a AND NOT b) OR c) ='1' THEN
  
Here the expression is calculated as bit and then converted to boolean as last action for the `IF` usage. 

But if you have a mix of `BIT` and `STD_LOGIC` it is not easy to write.
If b1 .. b3 are BIT types and s1 .. s3 are `STD_LOGIC` you can write

 b3 <= b1 AND b2;
 s3 <= s1 AND s3;
 
But you cannot write a mix of both.

 s3 = a1 AND b1; 
 
For that it is necessary to write:

 IF(a1='1' AND b1='1') THEN s3 = '1'; ELSE s3 = '0'; END IF;
 
Now the check is done on compilation level as boolean and the results are set.
For the routing process and the logic in FPGA it is exactly the same if there are no tristate or wired lines or such one, 
or better: If the `STD_LOGIC` signals have in any case only the values '0' and '1'. 
It is a property of the language VHDL, which regards that a `STD_LOGIC` can or may have also other values then '1' and '0'
as possibility. The given line does not give an information about that. 

Hence it is a little bit complicated for the code generation. 


=== Use cases of `STD_LOGIC` definitions

The `STD_LOGIC` was introduced in VHDL firstly to support simulation with the values 'U', 'X' etc. 
That is unrelated for the Java2Vhdl, because simulation is done in pure VHDL. 
But it may be important: If Simulation should be done with VHDL then all SIGNALs should be defined as `STD_LOGIC` and not as `BIT`.

Secondly, also important for Java2Vhdl, the Tristate and a wired or or wired and (pullup, pulldown lines) in the FPGA hardware
can only defined with `STD_LOGIC`. 
For that the type 

 @Fpga.STDLOGIC char mySignal;
 
supports definition of a data type with the 9 possible states. 
They are given as characters for the char variable and adequate used for Java simulation. 

The other possibility is to define

 @Fpga.STDLOGIC boolean mySignal;
 
In this case this variable is translated to `STD_LOGIC`, but only the two states '1' and '0' are supported. 
 


[#modulesOO]
== Modularity, with Object Oriented Approach

Of course, Java is an Object Oriented Language. It is important for ordinary software programming. 
The important common features for Object Orientation and their relations to hardware description approaches are shown
in the following sub chapter.

[#OOinVHDL]
=== Object Orientation approaches and their possibility for VHDL with the Java2Vhdl translator

* OO: Some **related data are combined in a class**.

* VHDL: This is also familiar in VHDL, using a TYPE RECORD and its instances. 
Secondly the classic modularity with one VHDL file per module fullfils this approach. 

* OO: Some **operations are related to the data**, the operations which works with the data.
* VHDL: it is possible to build RECORDs, and PROCESSes, which touches only data of exactly one record instance.
It means the RECORD definitions are oriented to the PROCESS definitions. 
The PROCESS is the operation or "method" related to the data. 
That is possible, not necessary in VHDL but may be seen as recommended.
But other than in Object Oriented writing style the PROCESS can be related only to one RECORD __instance__
and not to the `TYPE RECORD`, to the type as in Object Orientation. 
For the Java2VHDL translator the operation is defined type related of course (because of other reason in the constructor).
The translator generates the PROCESSes from that constructor code, but instance related. 
In the normal software Object Orientation the instance relation is made on run time
via the arguments of the method (in particular the instance pointer `this`, but also via other referenced instances as arguments).
The Java2Vhdl translator resolves this arguments and builds PROCESSes for each instance as result of translation.
It can be seen that the realization of the VHDL design is associated with a runtime, 
while the description in Java is the source for compilation.

* OO: **Encapsulation of data**. Data can be designated as `private` or `protected`. 
In both cases the data cannot be accessed from any other module, only from the own one ore derived ones in case of `protected`. 
The __package private__ designation in Java (without `public` keyword) is a furthermore possibility 
similar to the `friend` designation in {cpp}: 
Some modules can be associated to access there data one together, but the access is not possible from modules outside of this group.
+
This feature is not firstly for __protection__, is supports a proper modularity without too much data dependencies.

* VHDL: In a module in an own VHDL file the data are also encapsulated. 
But the Java2VHDL translator supports also a __flattened__ style with one VHDL file for some modules and some TYPE RECORD inside.
But because of encapsulation of the data in Java, the access to the records are also sorted. 

* OO: **aggregated modules**: Any module can have references to other modules. 
In UML (__Unified Modelling Language__) this references are designated as __composition__ (own sub module),
__aggregation__ (hard referenced other module, not changable) and __association__ (changeable). 
But the access to properties of the other module are organized. Only `public` or __package private__ members can be accessed,
see topic above. It is able to clarify whether an access can be done only via access operaions ("__getter__") 
or also to `public` data. The data can be `final` especially in Java to forbid writing, changing of the data in another module. 
This is an essential idea to decrease to much functional dependencies between modules. 

* VHDL: In the classic VHDL only the data flow via the Interface data (`ENTITY PORT`) is possible. 
This is not an aggregation concept, it is a dataflow concept. 
** But if a `TYPE RECORD` is seen as a module, in a flattened design (one file for more modules),
then the access to the data to other modules is immediately possible. 
Last not least, for the deployed design in the FPGA it is the same as using more as one VHDL file with ports. 
But from the view point of the VHDL source it is maybe more obviosly and more simple to read what`s happen. 
This is one of the basic idea of the __flattened__ design of the generated VHDL file. 
** From view point of the FPGA content description in Java, Aggregations are used, see chapter <<#aggr>>. 
Via the aggregations either public data can be accessed immediately, or the better approach is using the interface concept,
see <<#ifc>>. This is possible via modules in one flattened design. 

* OO: There is the possibility to use **derived types from an abstract type**: The thinking should not be: Have any type, and derive it. 
The better thinking way is: 
Have some different types, how to find common properties and their embodiment in an abstract type of all these different types. 
It means the derivation is the secons approach, the abstraction is the first one. 
This is done because dealing with common properties (abstraction) is a good idea.

* OO: Related to Java programming languate, firstly the interface concept is one of the abstraction: 
Defining of a comman access possibility. The interface is implemented then in any type (class). 

* OO: This feature of Object Orientation is very important for flexibility and testing. 
** A module can be connected to different similar but not necessary equal other types (aggregation in UML). 
** For testing an aggregated module can be replaced by a stub or mock which fullfils the interface for test approaches,
to execute module-related (unit) tests.

* VHDL: This is an interesting topic. Also in VHDL a module / unit test may be seen as important. 
The test can be done in a reduced real desing in an FPGA, and also on software level. 
Exactly this topic is realized in the Java2Vhdl translator. See chapter <<#ifc>>.  

[#VHDLmodules]
=== Modularity in classic VHDL

VHDL was developed in a time as Object Orientation was not familiar. 
And of course, is Object Orientation proper for hardware approaches? Not from the eyes of the 1980^th^. 
But from the eyes of hardware test approaches and translation possibilities of the 2020^th^! 

The modularity of VHDL is classic, it is a dataflow approach:

* Define an interface to a module, this is in the module the **__ENTITY PORT__** definition part. 
* This definition part should be repeated on usage as **__COMPONENT__** definition with the same content (a disadvantage, In C header files for that are used).
* On usage secondly in a **__PORT MAP__** signals should be connected. The connection of two modules needs extra signals. 

For that the writing and maintain effort is high. 
This is especially a problem on refactoring. 
The importance of refactoring in modern software technology is some more higher as in the 1980^th^,
related with the topics agile program development, complexity of solutions. 

For hardware description in Java a similar approach is possible using an `In` and `Out` inner class for the input and output signals. 
This is necessary if one module should translated as one module to VHDL. 

[#aggr]
=== More possibilities with Java2VHDL: References (aggregations) in Object Orientation kind

The following example code snippet come from a small project in

 cmpnJava_vishiaBase/src/test/java/org/vishia/
   fpga/exmpl/fpgatop/BlinkingLed_Fpga.java
 
and there used modules in this package tree.  

The modules in Java can be implemented in a __flattend__ form in VHDL. 
Then each inner class from one Java file (module) is one `TYPE RECORD` definition in VHDL. 
The top level VHDL file or also a module can have some such RECORD TYPE definitions.

Example start of an inner class in a module MyModule.java:

.Java: inner class for a PROCESS in VHDL
[source,Java]
----
//fpga/exmpl/modules/ClockDivider.java
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/modules/ClockDivider.java[tag=Q-data]
----

Builds the record in VHDL:

----
include::../../../test/testResult_Ref/Java2Vhdl/BlinkingLed_Fpga.vhd[tag=ClockDivider_Q_REC]
----

The RECORD is instantiated, here with one instance, but also more as one instances are possible:

----
SIGNAL ce_Q : ClockDivider_Q_REC;
----

In VHDL from inside any PROCESS a variable of another module (RECORD instance) can be accessed, 
because of the flattened form with RECORDS.

----
include::../../../test/testResult_Ref/Java2Vhdl/BlinkingLed_Fpga.vhd[tag=ct_Q_PRC-ce]
----

That is possible because of the flattened property. 
This is simple also for the routing process for FPGA tools.
The signal `ce` in the record instance `ce_Q` is immediately accessed. 
But:

The idea working flattened is bad for the real sources. It means that is not an approach for the Java sources.
But instead, the Java sources can work with aggregations. The adequate line in Java for the process of the other module looks like:

.Java: constructor for a PROCESS in VHDL usning ce
[source,Java]
----
//fpga/exmpl/modules/BlinkingLedCt.java
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/modules/BlinkingLedCt.java[tag=Q-Process-ce]
----
 
* In Java the access is not done immediately to the variable in the other class. Instead a `ref` is used.
* The name after `ref.clkDiv` is not related to Vhdl. It is a local name in the module class in Java, 
not related to the really used instance. 
* This is due to modularity. A module should not know which concrete instance of another module is used.
This is not to be clarified in the module. It must be clarified in the higher-level programming which uses the modules.

**How it is related:**
Any module can contain a `Ref` class with a `Ref ref` instance, here:

.Java: Reference usage
[source,Java]
----
//fpga/exmpl/modules/BlinkingLedCt.java
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/modules/BlinkingLedCt.java[tag=Ref]
----

That are aggregations in UML wording (Unified Modeling Language for Object Orientated software technology). 

As you see the name of the referenced module `clkDiv` is a private name, not the name of an existing instance in the parent module.
This is per se unknown, not determined which modules **and also which type of modules** are used.

The constructor of the `Ref` have to be called in the constructor of the module, because `ref` is `final`:


.Java: constructor for the Ref class
[source,Java]
----
//fpga/exmpl/modules/BlinkingLedCt.java
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/modules/BlinkingLedCt.java[tag=ctor]
----

Here it is important that the name of the arguments in the constructor is the same as the name of the aggregation reference
in the `Ref` class. That is not a problem and also a good style. It is necessary for the translation to VHDL.

Now, in the top level in Java all modules should be instantiated. The Java-toplevel decides which modules are used.
For that there is a `Modules` inner class:

.Java: Module class defines the used modules with their relations
[source,Java]
----
//fpga/exmpl/modules/BlinkingLedCt.java
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/fpgatop/BlinkingLed_Fpga.java[tag=Modules]
----

Here three modules are defined which are used in the top level of the FPGA. 
In the constructor of the modules the aggregations to the other modules are defined.
Note that also a `module.init(...)` can be used beside the constructor. 
This is necessary if circular dependencies are needed. For the Java2VHDL translation both can be used,
arguments of the constructor and arguments in the associated `init(...)`, not shown here.
 
The name of the modules (the composite reference name in Java) build the name of the RECORD instances in VHDL:

----
include::../../../test/testResult_Ref/Java2Vhdl/BlinkingLed_Fpga.vhd[tag=RecordSignals]
----

On translation from Java to VHDL an index (TreeMap in Java) is built for each module 
which associates the intern name of a reference to a module with the real used module. 
This index is internally used for translation, but also reported in the report file (option `-rep:path/to/file.txt`)

----
include::../../../test/testResult_Ref/Java2Vhdl/BlinkingLed2Vhdl_report.txt[tag=ct-Ref]
----

Now, while generating the `PROCESS` for the module `ct`, this association index is used 
to assign the `clkDiv` in Java with `ce` as name of the RECORD instance in VHDL.

How is this index built:

* The name of the instance in Java given as actual argument of the constructor `BlinkingLedCt` as `this.ce`.
`this.` is only for Java internals, `ce` is used.
* The name of the formal argument of the constructor of `BlinkingLedCt` is `clkDiv`. It is also gathered.  
* This both names are stored in the index shown above. 
* The name of the actual argument of the `Ref` constructor and also the name of the reference itself should be the same: `clkDiv`.
This is necessary as style guide. It should not be a problem. 
Test and translation of this stuff may be also possible, but a non necessary effort.

So the Object orientated writing style in Java is translated 
to a flattened immediately access to the correct SIGNAL (usual a Flipflop, a register etc.). 

[#ifc]
=== Interface technology in Java for VHDL

The last chapter has shown using Object Orientation with aggregations and their association to instances.
That is necessary for flexibility in module usage (which combination) and also for the **test of modules**

There is one more approach: using interface technology.

In the chapter above it is able to associate, which module is used. 
But the access inside the module is inflexible. 
The variable name of the module is immediately used, in the example `q.ce`.

Two things should be free to do:

* Changing of internal names in a module for further development. 
Using modules should not be refactored. 
That is also the basic idea of **private** encapsulation in the Object Orientation.
* Using **another module should be possible** with similar properties for using but another internal design  
This idea is the abstraction and inheritance in Object Orientation. 
It is like in daily life. You need a car to drive. Which car is not important. 
All cars are basically similar, there are exactly equal in the required properties.  

Look to another part of the example: 

.Java: interface usage
[source,Java]
----
//fpga/exmpl/modules/BlinkingLedCt.java
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/modules/BlinkingLedCt.java[tag=Q-Process-ifcUsg]
----

This is a snippet from the `BlinkingLedCt PROCESS` in Java:
A reset information is requested. If reset is given, then the counter `ct` is set to its reload value.

But it is not designated here from where reset is coming and how it is built, 
and also from where the reload value is coming and how it is built.
This should be clarified outside of the module. The module only needs connection for it. 

The translated VHDL design looks like:

.VHDL: generated code of interface usage
[source,VHDL]
----
include::../../../test/testResult_Ref/Java2Vhdl/BlinkingLed_Fpga.vhd[tag=ct_Q_PRC-ifcUsg]
----

Here the relations to the reset signal and the reload value is full clarified:
A signal from another `RECORD` instance (another module) is used for reset,
and the reload value is defined as constant in the VHDL code above: 

.VHDL: constant definition due to interface operations
[source,VHDL]
----
include::../../../test/testResult_Ref/Java2Vhdl/BlinkingLed_Fpga.vhd[tag=BlinkingLedConstants]
----

But in another usage configuration of the same module, without change of the Java code of the module, 
the reload value can for example come from another Signal vector as for example

.VHDL: other result of interface usage
[source,VHDL]
----
          ct_Q.ct <= otherRecord.reloadVal;   
----


==== How should the interface technology be used 

The invocation of the interface relation uses the referenced modules [J]`ref.reset` and [J]`ref.cfg` for this both values. 

Look on the definition of the 

.Java: Reference class definition
[source,Java]
----
//fpga/exmpl/modules/BlinkingLedCt.java
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/modules/BlinkingLedCt.java[tag=Ref]
----

As you see, the type of the [J]`ref.reset` is [J]`Reset_ifc`, as also the type of [J]`ref.cfg` is [J]`BlinkingLedCfg_ifc`.
Look firstly to the defintion of the [J]`Reset_ifc`:

.Java: Definition of Reset_ifc:
[source,Java]
----
//fpga/exmpl/stdmodules/Reset_ifc.java
include::../../../main/java/srcJava_vishiaFpga/org/vishia/fpga/stdmodules/Reset_ifc.java[]
----

Using of interfaces is very proven in Java (as also another Object Orientated Languages),
and it is not so complex to translate it to VHDL, if some sensible simple style guides are additional regarded.

Now, any module can implement this [J]`Reset_ifc`. 
The reference goes to the module type or Java class [J]`Reset` as you can see in the module definition in the top level.
How the referencing works, is explained in the chapter above. 
For this example the reference is clarified on the outer level of modularity, on usage of the module:

.Java: Module definition and relations
[source,Java]
----
//fpga/exmpl/modules/BlinkingLedCt.java
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/fpgatop/BlinkingLed_Fpga.java[tag=Modules]
----

The inner reference name [J]`ref.reset` is associated to the module [J]`Reset res`, 
and [J]`ref.cfg` is associated to the Fpga top level module class itself, mediated via the constructors
as described in chapter above.

Now, the module [J]`Reset` implements the following operation:

.Java: Implementation of Reset.reset():
[source,Java]
----
//fpga/exmpl/stdmodules/Reset.java
include::../../../main/java/srcJava_vishiaFpga/org/vishia/fpga/stdmodules/Reset.java[tag=classdef]
  .....
include::../../../main/java/srcJava_vishiaFpga/org/vishia/fpga/stdmodules/Reset.java[tag=reset()]
----

It's very simple: If accesses the variable [J]`res` in its own inner class [J]`q` 
which is the PROCESS class for the reset functionality. 
This is the detail of this [J]`Reset` module.

The Java2Vhdl translator evaluates this term in the context of this module which is given as reference.
Hence the result is the already above shown VHDL code:

.VHDL: generated code of interface usage
[source,VHDL]
----
include::../../../test/testResult_Ref/Java2Vhdl/BlinkingLed_Fpga.vhd[tag=ct_Q_PRC-ifcUsg]
----

Generally, only the term of the [J]`return` statement is evaluated. 
If the interface operation contains more statements, it is usable for simulation on Java level. 
For the ordenary software execution of interfaces concepts in Java as also other programming languages
the interface operation can also change data and do anywhich else. 
But this "__full freedom to do whatever you want__" is also criticized in some software writing guidelines.
Normally it is a good style to prevent or forbid changes in another software module on only access operations. 
Changes should be done with (also maybe interface-) operations which are named `do...` or `process...` or `exec...`
or such else. For that things the processes in VHDL are responsible. 
It means execution routines cannot be invoked in the Java context for VHDL hardware descriptions. 

But the [J]`return expression` can be more complex, for example can contain logical combinations, access to bit ranges,
comparison and all what is possible also in other expressions. 
This expression is generated inside the accessing PROCESS. 
If the same interface operation is used more as one time in different contexts, this operations are generated on any access.
It is similar as execution of the operation in the Java runtime. Also there any access executes the statements again. 

It means, the PROCESS of the module can prepare proper signals for simple access if it is expectable that this signals are used more as one time.
On the other hand the optimizer while routing can accomplish the aggregation of multiple equal accesses.
How these accesses are to be designed is up to the Java description of the VHDL developers.

But, let's have a look to the second interface usage of this example. 

.Java: interface usage
[source,Java]
----
//fpga/exmpl/modules/BlinkingLedCt.java
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/modules/BlinkingLedCt.java[tag=Q-Process-ifcUsg]
----

The request is adequate, a value should be accesses. It is not first intendet that this is a constant value.
It can be also a signal which contains this __reload__ value as dynamic information. 

Especially for tests sometimes signals are terminated by fix values, if this functionality is not in focus yet.
The signals should be fullfilled, of course, but inputs may be always `false` or `'0'` for this test condition
or for more simple usage of a module. The last hint is also important:
A module can contain more functinaltity as necessary for the amount of usages.
If inputs are terminated with constants and outputs are not used, then the routing process will remove this unnecessary parts.
The sources can contain it, without disadvantages. 
It means also that a module should not be prepared or adapted for specific usage situations.
It can be uses "__as is__", and the outer signals and conncetions determine which is really implemented in the FPGA.

For that reason a second simple for of interface definition is supported by the Java2Vhdl converter. 
The interface to access the [J]`time_BlinkingLed()` is implemented here in the main or top level, for simple determination:

.Java: interface implementation for a constant
[source,Java]
----
//fpga/exmpl/modules/Fpga_BlinkingLed.java
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/fpgatop/BlinkingLed_Fpga.java[tag=time_BlinkingLed_topImpl]
----

The here written comment is firstly not important for the general explaination. The essence is:
The [J]`return ...` expression contains only one term, it is a constant. If this situation is detected,
this constant value is generated in VHDL with the name of the module and the name of interface operation, it`s unique.
The result is (already shown above): 

.VHDL: constant definition due to interface operations
[source,VHDL]
----
include::../../../test/testResult_Ref/Java2Vhdl/BlinkingLed_Fpga.vhd[tag=BlinkingLedConstants]
----

The other constant comes from a second similar interface operation. Also the access uses the name of the constant.

The advantage of building a constant element is: It is obvious in VHDL. 
Elsewhere only the constant value will be written there as evaluation of the expression, and the back tracking to the Java code is difficult.

If for example inputs are terminated by a constant to prevent usage, the generated VHDL code contains for instance:

.VHDL: constants for input termination example
[source,VHDL]
----
CONSTANT Toplevel_Fpga_inputX : BIT := '0';
 ....
PROCESS ...
  IF Toplevel_Fpga_inputX = '1' THEN
    ...
----     

In VHDL you see that the input of the module is used, but the expression is never true. 
Hence, the router removes this part, proper for the use case.

The idea to implement such termination interfaces on the top level comes from the idea, 
that the top level, or the whole design decides about usages of details of some modules. 
Another module as stub is not necessary. It simplifies the design.
But of course also another module can be used. In the example design for the Blinking Led a secons solution can be activated:
The stub for the constants are defined as extra class, but (at first) in the same module. 
Java allows only one public class per file, but this class does not need to be public. 
Of course an extra file can also be written, for example or especially for parameter values
which also can be defined in this kind. This parameter Java file can be generated for example from a data base. 

  

==== How does the interface technology works 

There are two things to considerate:

* The refernced module
* the interface operation.

On translation of each module the interface operations (only in the first level classes of each file, not in inner classes)
are gathered. The return  statement is searched and evaluated.

Either it is a simple constant, then the constant is stored in the [J]`idxConstDef`: 

* All constant definitions: link:../../docuSrcJava_vishiaBase/org/vishia/fpga/J2Vhdl_FpgaData.html#idxConstDef[J2Vhdl_FpgaData.html#idxConstDef]

and the const definition is stored in 

* constant definition of an interface operation: link:../../docuSrcJava_vishiaBase/org/vishia/fpga/J2Vhdl_ModuleType.IfcConstExpr.html#constVal[J2Vhdl_ModuleType.IfcConstExpr.html#constVal].
Or if it is not a simple constant the expression is stored in 

* expression of an interface operation: link:../../docuSrcJava_vishiaBase/org/vishia/fpga/J2Vhdl_ModuleType.IfcConstExpr.html#expr[J2Vhdl_ModuleType.IfcConstExpr.html#expr]

Both alternatives are then stored module-type-related in 

* interface operation per module type: link:../../docuSrcJava_vishiaBase/org/vishia/fpga/J2Vhdl_ModuleType.html#idxIfcExpr[J2Vhdl_ModuleType.html#idxIfcExpr]

On translation this table is reported in the `-rep:reportfile.txt` for this example as:

----
include::../../../test/testResult_Ref/Java2Vhdl/BlinkingLed2Vhdl_report.txt[tag=Type-Reset]
----




If an interface operation is detected as part of an expression, then the reference is dissolved, detecting the type of the reference,
and the interface operation is searched (binary search) in that module type related index.

Then either the constant definition is immediately used,
or the given expression is evaluated as any other expression too, whereby the module context is switched.

=== Overview modularity


The next image should show the variants in a common way (unrelated to the example), 
also with public immediately access in the modularity:

image:../../img/Fpga/Modularity_ObjOr.png[Modularity in Java] 
 
 
* The `Module_A_In` in this image is an inner `In` class adequate to the VHDL approach using `PORT`. It is possible.
* Left side an immediately access to a inner variable in Java is shown. The variable should be `public`. 
The disadvantage for that is, that the white `Module_A` should know the defintiion of `Module_X`. 
That is possible and also familiar in Java. 
It is bad for module test, because on testing also an instance of the `ModuleX` should be present in the test environment, 
exact this module or a replacement but with the same package path, which is terrible for source maintaining (version management). 
* But also for that immediately usage the inner aggregation `refX` is translated to the `ref1` on usage. 
It means the type should be known, but the instance is determined outside. This is important if more as one instance for one type is existing. 
* Right side the interface usage is shown. The interface operation should have the same name as the accessed variable.
That is not necessary from the view point of Java. It is necessary for the Java2Vhdl translation. But it is possible.
* You can connect different implementation modules also on FPGA level in VHDL. 
It means the variable `stateY` can exist in different records types. Only the name is determined. 
* Now the advantage for testing is shown. That is only done in Java, not on VHDL level. 
That's why the test implementation of the `interface_K` can use any implementation, should not access exact one variable. 
* Note that also for the module implementation for Vhdl translation the access operation here for `stateY` 
can contain more as the simple access to the variable, for example log informations, adaption, a debug break point.
That is all possible on Java level, not translated to VHDL. 
For VHDL anytime the simple access to the record signal with the same name as the access operation is translated.

 

== Timing constrains for place and route

The next examples are related to the Lattice Diamond tool. 
Whether constrains should be given in the same syntax form for other tools (Xilinx & co) is not yet clarified.

See also basic considerations in the chapter <<#BasicTiming>>

Simple, the whole FPGA design should have the same clock. 
That is a basic mentioned in chapter <<#BasicFuncSim>>, and it makes sometimes easier to manage timing and functionality.
But this is precisely why a higher clock frequency is usually used as the base clock, even though certain functions can operate in slower cycles.

The basic in VHDL for this use case is:

----
--From example: BlinkingLed_Fpga.vhd
include::../../../test/testResult_Ref/Java2Vhdl/BlinkingLed_Fpga.vhd[tag=ct_Q_PRC-ce]
  --.... logic working only if ce is set
  END IF;
----

It is a clock enable strategy. The Flipflops remains unchanged if `ce='0'`.

The adequate form in the Java src is similar:

.Java: constructor for a PROCESS in VHDL using ce
[source,Java]
----
//fpga/exmpl/modules/BlinkingLedCt.java
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/modules/BlinkingLedCt.java[tag=Q-Process-ce]
      //.... logic working only if ce is set
    }
----

Supposed, this `ce` signal comes with a cycle of 160 ns as in the example, you can write a constrain
in the lpf file of the lattice Diamond tool:

----
PERIOD PORT "clk" 10.000000 ns ;
MULTICYCLE FROM GROUP "ct_q" TO GROUP "ct_q" 16.0 X;
----

It means that the routing regards the basic clock frequency of 100 MHz or 10 ns cycle,
but between the members of the `GROUP "ct_q"` the timing path can have till 16 times slower, 160 ns. 
With this information the place and route tool can route firstly the fast paths, then with the remaining resources the slower paths.
The place and route tool is specialized for that requirement. 
In result you have a proper routing result without timing violations if your requirements to timings are not too hard.
But it is precisely because slower paths are allowed, because the possible cycle is slower, that this is possible.

But the remaining quest is: How to build the groups?

Here the Java notification and the test at Java level helps. 

TODO supplement the example with timing check, to document. 



== Test

The Test of the logic is a very important part. 

General a test should be done in two categories: 

* Test under exact defined conditions expecting dedicated results. This is important for two situations:
** Test of features which are assumed in requirements.
** Repeated tests after changes to fast and automatic clarify, all is ok.

* Test under accidently conditions. This tests are important to study the behavior independent of planned tests
and exactly defined requirements. 
** It is possible that some conditions are not exactly defined, but that definitions should be intrinsinc necessary.


Furthermore, the tests should be done in three situations:

* Test of the ready to use logic in the routed FPGA under several conditions (several input signals),
of course in both categories as above presented, planned tests and accident tests (sometimes denoted by "__white noise tests__").

* Test of the whole logic on Java level with dedicated test cases,
or maybe also for accident inputs. Whereas a random value generator may be used in software.
But of course the accident situations follows only the programmed randomizations, this is not a "__white noise test__".

* Test of modules ("__unit test__"). Usual for that only planned tests are determined.
The behavior of a module should follow exactly situations, this follows the denotation "__design by contract__".
The contract of the behavior of a module should be well defined. A module should be manageable (rather than a complex system).

These are pure basics about tests that are generally applicable.


=== step and update operations

The content of the `step(int time)` and `update()` operations are not used for the VHDL translation. 
Essential for the VHDL translation are only the existence of the inner classes designated by the annotation `@Fpga.VHDL_PROCESS`
in the modules and the instantiation of the modules in a `class Modules` in the top level file and also possible in modules for sub modules.

It means the (manually programmed) content of this routines should follow the existing module instances and process classes. 
Then only the behavior of the test is identically with the original FPGA behavior. 
It means, intrinsic, this operations should be generated also for Java level. But this is not done yet. 

The step routine prepares the states before the next clock. 
The update routine is the clock, it is the manifestation for the next state.


=== Input signals for test simulation in Java

If you are **testing the whole FPGA design** usual the top level file has a `Input` and `Output` inner class 
with the designated `input` and `output` instance which presents the pins of the FPGA. 
Hence should only set the elements of the `input` with the appropriate values.
This input values can come from simple test bed algorithm, or from more complex algorithm maybe also fet from values in tables,
the test cases. 

If you are **testing a module** usual the module has interface connections. 
You should satisfy this interface requirements by implementations in the test bed, for the appropriate input signals. 


=== Output signals for manually evaluation  of the test results

With given tools of FPGA simulation a graphical output is usual for instance: 

image:../../img/Fpga/ExampleUsual_wave.png[]

Of course an adequate approach is possible for Java simulation because Java has graphical possibilities,
it can be programmed in a specific way, or given routines in libraries of from other tools are usable.
But is this the best one?

The very simple solution presented below is also satisfactory:  

----
----


=== Test of modules or the whole design on Java level



=== Output of test signals for manually study





== Writing style of logic - data assignment versus situation thinking

It is a general question, orientation to data assignment or situation evaluation. 
What is meant by this?

* __Situation evaluation__: Programming is a familiar idea of program flow. 
The typical construct is `if ... then ... else`. 
"__If a situation is given, then do this and that__".
This is also the prevailing mindset for VHDL and for the programming style of the 1980^th^ 
(before Object Orientation became really familiar). 

* __Orientation to data assign__:
The real truth of programming is: Influencing data.
That is also one of the ideas of Object Orientation. 
The __objects__ are the data. Program flow and operation is only a way to influence the data.
The quest is the state of data. The flow is only a mediator for action.

In graphical models such as Simulink or Labview immediately a __data flow__ is modeled. 
This is a data flow between function blocks, another level, nor related here. 
This data flow concept seems to be in opposite to the modeling with UML, 
which shows not a flow but data relations especially in Class- and Object Diagrams.

Another topic is __functional programming__. This is more __oriented to data assign__ 
because all is result of a function, and a function is the result of the input data. 
This is mentioned here only as additional information.

Look on examples for __Situation evaluation__ versus __Orientation to data assign__:

=== Style: Situation evaluation, program flow

----
 if(condition) {
   data = changed;
 } else if(other_condition) {
   data = other_input;
   other_data = changed;
 }
----

Here it is not clarified whether the `data` are changed anywhere other too,
as well as the `other_data` are changed in one of the given situation.
The change of data are not well described. 
But the reaction of situations (test a `condition`) is well described.
Usual the condition is only tested one time. 

=== Style data assignment orientation (data flow)

----
 if(condition) {
   data = changed;
 else if(other_condition) {
   data = other_input;
 } else {
   //comment: data remain unchanged. 
 }
 if(other_condition) {
   other_data = changed;
 } else if(specific_condition) {
   other_data = specific;
 } else {
   //other_data unchanged in all other situation
 }  
----

Here we have two program blocks, because two different data are handled. 
The data are not related, except one `other_condition` influences both. 
But the conditions are secondary. 
Each program block for one data should be complete for this data.

The disadvantage of data assign orientation: Usual it needs more code. 
The test of conditions are programmed more as one time. For all data extra.
That needs also more runtime for the program in a controller (if the compiler does not optimize). 

The advantage of data assign orientation is: The program clearly shows, how data are changed. 
If one looks on the part for one data specification, it is complete. 
The data will not be changed anywhere else. 

In practice, both approaches are often combined.
Fundamental situation as "clear", "reset" are programmed with the __situation__ approach:
"__what's happen on clear:...__".
But for details the data orientation should be better. 

The argument of longer execution time is not applicable for the hardware design
if complex combinatoric are stored in intermediate variable.
If that is not done, the router may optimize the combinatoric too. 
Only the readability of the code is decisive.

=== Ternary or condition operator in Java: condition ? a : b

Now, for thinking to data orientation, in Java (as also in {cp}
the so named __ternary__ or condition operator can be used:

 data = condition ? changed : other_input;
 
This is the simplest form with two variants. 
It can be more complex:

 data = condition ? changed
      : other_condition ? other_input
      : data;
      
This is the same effect as the `if` in the examples above. 
But it is well obviously. Also the `else` branch is exactly determined. 
The compiler of software languages will remove the unnecessary assignment
for the unchanged data. 
For this situation it is well documented that the data are used unchanged. 

In Java you can use a `final` keyword for such data:

 final int data = condition ? changed
                : other_condition ? other_input
                : old_data; 

This is similar as link:https://en.wikipedia.org/wiki/Functional_programming[] functional programming. 
With the final keyword the compiler has more capabilities to optimize.

And now, for hardware design:

The new state of a FlipFlop or a FF group is complete determined by such an final functional construct.
The logic is obvious at a glance. 

=== Solutions for pure VHDL

As mentioned above, VHDL was created in a time (1980^th^) where structured programming was familiar. 
Additional to the known `if ... then ... else ... end if;` VHDL knows:

* 'case '__selection__ `is when` __choice__ `=>` __statements__  +
This is also typical for situation thinking. The __statements__ can contain any assignment.
The __selection__ describes which situation is checked.

* __assignment__ `<=` __value1__ `when` __condition1__ +
  __value2__ `when` __condition2__ +
  `else` __valueelse__; +
This is exactly the behavior for the data assignment thinking.
Only one variable is under consideration. 
It is set under several conditions. 

This `when ... else` statement was introduced also for using in processes
(behavioral programming) with VHDL-2008. It is ideal for this case.
But unfortunately VHDL-2008 doesn't seem to be considerate by all tools and all thinking: 

link:https://hardwarecoder.com/qa/73/vhdl-when-else[]

__4. Try to only use when else outside a process even though it's supported in VHDL-2008. 
Why? Because in 2020, some synthesis tools still have some bugs compiling VHDL-2008. 
Perhaps in the future this won't be an issue. 
Plus, if you have to support an older FPGA using older tools, 
you won't have 2008 as an option. Keep these issues in mind when you code. 
There are better options than when else if you need to have it in a process, like using case instead.
__
  
It means it is not able to use for a tool independent translation from Java.

=== Java2VHDL for condition operator

Hence, conclusion, in processes only `IF` can be used for translation of the Java condition operator.

----
 //Java:
 data = condition ? changed
      : other_condition ? other_input
      : data;
----

is translated to:

----
 IF condition THEN data <= changed;
 ELSIF other_conditon THEN data <= other_input;
 ELSE data <= data;
 END IF;
----

whereas the last line can be removed. This is the same behavior as written with the conditional operator in Java.
What is obviously: The same left side term for the data assignment (`data <=`) is written for each branch.
But this is not an disadvantage. It is readable, and the router and simulation tools with VHDL can proper deal with it.
Only the readability of the source is a little bit not optimal because one line may contain a writing mistake.
But because it is generated code - no problem.

Unfortunately outside of a process `IF THEN ELSE` cannot be used, 
here the `WHEN` construct is used for translation of such an conditional expression. 

The same problem occurs on conversion of a bit in `BIT` logic from `STD_LOGIC`:

----
  -- in a PROCESS:
  IF myBitValue = '1' THEN myStdValue <= '1';
  ELSE myStdValue <= '0';   
  END IF;
----

and outside of a `PROCESS`

----
  myStdValue <= '1' WHEN myBitValue = '1' ELSE '0';
---- 




=== Multiplexer in hardware design, problem of WHEN ELSE

In Java it is very simple to write in an expression:

 boolean q = a & (b ? c : d) | e;
 
 In this case `c` and `d` is multiplexed by selecting with `b`. The rest is boolean logic.
 In VHDL theoretically a
 
  c WHEN b='1' ELSE d
  
is existing. It works outside of a process. 
But this construct doesn't seem to be considerate by all tools and all thinking: 

link:https://hardwarecoder.com/qa/73/vhdl-when-else[]

__4. Try to only use when else outside a process even though it's supported in VHDL-2008. 
Why? Because in 2020, some synthesis tools still have some bugs compiling VHDL-2008. 
Perhaps in the future this won't be an issue. 
Plus, if you have to support an older FPGA using older tools, 
you won't have 2008 as an option. Keep these issues in mind when you code. 
There are better options than when else if you need to have it in a process, like using case instead.
__

It means, the simple expression for a multiplexer, which is familiar in hardware,
is not possible for VHDL. 

But instead, VHDL likes to see `IF` constructs:

 IF b='1' THEN t = c; ELSE t = d; END IF;
 
This works also in processes, it is a basic, supported, known. 
But what is the disadvantage: 
As part of an expression we need a temporary variable. 
And this part of expression should be extracted as extra statement.

----
  PROCESS
  -- Java: boolean q = a & (b ? c : d) | e;
 
  SIGNAL b_sel : BIT;  --process variable
  BEGIN
  IF b = '1' THEN b_sel := c; 
  ELSE b_sel := d; END IF;
  q <= (a AND b_sel ) OR e;
----
 
This complicates the readability. But we have VHDL, the best and safe language for hardware. 


=== Programming in loops

Also VHDL knows loops. If you following
link:https://vhdlguide.readthedocs.io/en/latest/vhdl/behave.html#problem-with-loops[]
then loops should not be used. 

In software two types of loops should be well distinguished:

* Classic loops for repeated execution till a condition is met.
It is typical a `while` loop, or `repeat - until`.

* Loops only to execute an algorithm for all given instances. 
That is not really a execution in the loop, it is only written as loop in software
to process all given instances. This can be done also parallel and also sequentially.
But because the instances are contained in a so named __container__ the loop works for all member of the container.
This is typically a `foreach` loop. In Java it is written as:

----
 //Java
 for( Type element : container ) {
   //do for all element.
 }
---- 
 
Such constructs are parallelizable also in software, for example distributed on several cores of a processor.
Why: Because all operations which are executed in a loop one after another are independent.
It means the order of execution is not important. 

This scheme can now be used for hardware designs for parallelization. 
Of course the FPGA should have enough resources for the task.

It is also interesting that each element in a container can have a different derived type. 
It means really, different operations are executed (via virtual operations).
Now, thinking in hardware: You have a planned container with elements, the elements are a little bit different
and you need a design for this elements:

* a) You write code for each element extra.
* b) You use a for-each loop. But because the type of the elements are only known in runtime 
(depends on other program parts which may be not in focus)
such a VHDL code as generated parallel code can be built also especially in run time. 
The executed statements are not executed, instead they produce VHDL code.

This is another approach, currently not supported by the Java2VHDL concept, maybe done in future.   



== Literatur




link:https://www.elektronikpraxis.vogel.de/fpgas-mit-cc-programmieren-herausforderungen-bei-hls-design-flows-a-826858/[]


