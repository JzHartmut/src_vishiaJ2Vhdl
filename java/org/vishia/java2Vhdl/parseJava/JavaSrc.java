package org.vishia.java2Vhdl.parseJava;

import java.io.IOException;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.TreeMap;

import org.vishia.util.Debugutil;
import org.vishia.util.SetSrcInfo_ifc;


/**This file was originally generated by {@link org.vishia.genJavaOutClass.GenJavaOutClass}
 * as wrapper and then supplemented with special features.
 * Note that the super class of this and all super classes from the inner classes
 * are generated accordingly the syntax in {@linkplain JavaSyntax.zbnf.html}.
 * <br>
 * It defines the usage level for the data class for the parse results. 
 * This usage classes can be adapted. 
 * <br>
 * Adaptions are made in:
 * <ul>
 * <li>some toString() operations completed
 * <li>{@link Expression}, especially {@link Expression#prep(Appendable)}
 * </ul>
 * 
 * 
 * */
public class JavaSrc extends JavaSrc_Base {

  /**Version, history and license.
   * <ul>
   * <li>2022-10-19 bugfix {@link Expression#prep(List, Appendable)}: Now also an unary operator of an nested expression is regarded.
   *   It was missing. "a * -(c/d)" or "NOT state == StateXY". Till now only the unary operator for a simple operand was regarded.
   * <li>2022-10-19 Expression.toString(...) changed back to version ~2022-03 because test of RPN , without source information
   * <li>2022-03-29 new {@link Statement#isAssignExpr()}
   * <li>2022-03-29 Hartmut chg: {@link Expression#prep(Appendable)}: It must not return a new Expression, 
   *   instead replace the existing {@link JavaSrc_Base.Expression_Base#exprPart} list with a new list.
   *   Reason: This Expression instance is referred any else where, the new instance is not involved. 
   *   This problem was obvious if a parse result is used twice. The first usage has use the correct prepared Expression,
   *   but the second usage has used the original one and does not prepare again, because the {@link Expression#isPrepared} flag was also set.
   * <li>2022-03-29 Hartmut chg: {@link Expression.StackOperator} now stores the whole part because its trueFalseValue,
   * <li>2022-03-xx Hartmut chg: {@link Expression#prep(Appendable)} 
   * <li>2022-03-xx Hartmut chg: some toString() operations. 
   * <li>2012-02-28 Hartmut created: from generator {@link org.vishia.zbnf.GenZbnfJavaData} and then enhanced.
   * </ul>
   * <br><br>
   * <b>Copyright/Copyleft</b>:
   * For this source the LGPL Lesser General Public License,
   * published by the Free Software Foundation is valid.
   * It means:
   * <ol>
   * <li> You can use this source without any restriction for any desired purpose.
   * <li> You can redistribute copies of this source to everybody.
   * <li> Every user of this source, also the user of redistribute copies
   *    with or without payment, must accept this license for further using.
   * <li> But the LPGL is not appropriate for a whole software product,
   *    if this source is only a part of them. It means, the user
   *    must publish this part of source,
   *    but don't need to publish the whole source of the own product.
   * <li> You can study and modify (improve) this source
   *    for own using or for redistribution, but you have to license the
   *    modified sources likewise under this LGPL Lesser General Public License.
   *    You mustn't delete this Copyright/Copyleft inscription in this source file.
   * </ol>
   * If you are intent to use this sources without publishing its usage, you can get
   * a second license subscribing a special contract with the author. 
   * 
   * @author Hartmut Schorrig = hartmut.schorrig@vishia.de
   */
  public final static String version = "2022-10-20"; 


  public void postPrepare() throws IOException {
    if(this.getSize_classDefinition() >0) //...for
    for(JavaSrc.ClassDefinition rClass: this.get_classDefinition()) {
      postPrepareClass(rClass);
      JavaSrc.ClassContent clazzC = rClass.get_classContent();
      Iterable<JavaSrc.ClassDefinition> iClasses = clazzC.get_classDefinition();
      if(iClasses !=null) {
        for(JavaSrc.ClassDefinition iClass: iClasses) {
          postPrepareClass(iClass);
        }    
      }
    }
  }
  
  
  private void postPrepareClass ( JavaSrc.ClassDefinition rClass ) throws IOException {
    JavaSrc.ClassContent clazzC = rClass.get_classContent();
    Iterable<JavaSrc.ConstructorDefinition> ctors = clazzC.get_constructorDefinition(); 
    if(ctors !=null) {
    for(JavaSrc.ConstructorDefinition ctor: ctors) {
      postPrepareStatements(ctor.get_statement());
      
    }}
    Iterable<JavaSrc.MethodDefinition> methods = clazzC.get_methodDefinition(); 
    if(methods !=null) {
    for(JavaSrc.MethodDefinition rOper: methods) {
      postPrepareStatements(rOper.get_methodbody().get_statement());
      
    }}
    
  }
  
  
  
  
  private void postPrepareStatements ( Iterable<JavaSrc.Statement> statements ) throws IOException {
    if(statements !=null) {
     for(JavaSrc.Statement rStmnt: statements) {
      JavaSrc.Expression rExpr = rStmnt.get_Expression();      // statement is an expression
      if(rExpr !=null) {
        rExpr.prep(null);
//        if(rpnExpr !=null && rpnExpr != rExpr) {
//          rStmnt.set_AssignExpression(rpnExpr);  //change it
//        }
        //JavaSrcPrep.ExpressionPrep rpExpr = new JavaSrcPrep.ExpressionPrep(rExpr, null);
        Debugutil.stop();
      }
    }}
  }
  
  
  
  /**Searches the import path to a given class type.
   * @param type This class should be named immediately in one of the import statements.
   *   Note: An asterisk-import is not supported here, it is a too much effort. 
   *   It is style guide: name the exact class file in import.
   * @return null if not found. This may be seen as exception, then a nullpointerException may be provoked.
   */
  public String findTypeInImport(String type) {
    for( ImportStatement st : super.importStatement) {
      if(st.class___ !=null && st.class___.equals(type)) {
        return st.getPath();
      }
    }
    return null; //not found, either a module in the same package or may cause an exception.
  }
  
  

  /**Class for Writing the Component AccessRight.*/
  public static class AccessRight extends JavaSrc_Base.AccessRight_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component ExprPart.*/
  public static class ExprPart extends JavaSrc_Base.ExprPart_Base {
  
  
    String sUnaryOp;
    
    boolean bStackInstance;
    
    public ExprPart ( ) {
      Debugutil.stop();
    }
    

    public String get_unaryOperator ( ) { return this.sUnaryOp; }
  
    public String getStrValue ( ) {
      if(super.value == null) return null;
      else return super.value.toString();
    }
  
    
    public void toString(StringBuilder sb) {
      if(super.operator !=null) { sb.append(super.operator). append(' '); }
      else sb.append("@ ");
      if(this.sUnaryOp !=null) { sb.append(this.sUnaryOp); }
      if(super.value!=null){ sb.append(super.value.toString()); }
      else sb.append("@");
    }
    
    
    @Override public String toString ( ) { 
      StringBuilder sb = new StringBuilder();
      toString(sb);
      return sb.toString();
//      return (this.sUnaryOp !=null? " " + this.sUnaryOp : "")
//      + (super.value==null ? "@" : super.value.toString())
//      + " "    
//      + (super.operator!=null ? super.operator : "@")
//      ; //"TODO toString";
    }
  
  }

  
  
  /**This is an ExprPart but with special features,
   * hence derived.
   *
   */
  public static class ExprPartTrueFalse extends ExprPart {
    Expression trueExpr;
    Expression falseExpr;
    
    ExprPartTrueFalse(ExprPart src) {
      super._srcColumn_ = src._srcColumn_;
      super._srcFile_ = src._srcFile_;
      super._srcLine_ = src._srcLine_;
      super.operator = src.operator;
      super.sUnaryOp = src.sUnaryOp;
      super.value = src.value;
    }
    
    public Expression get_trueExpr() { return this.trueExpr; }
    
    public Expression get_falseExpr() { return this.falseExpr; }
    
    @Override public String toString() {
      return super.toString() + " ? {" + this.trueExpr.toString() + "} : {" + this.falseExpr.toString() + "}";
    }
    
    
  }


  public static class Assginment {
    Reference refLeftVariable;
    SimpleVariable leftVar;
    SimpleValue leftVariable;
    Expression expr;
  }
  
  
  
  public static class AssignExpressionGroup extends Expression {
    List<Expression> assignments;
    
    @Override public String toString ( ) { 
      StringBuilder b = new StringBuilder(100);
//        for(ExprPart part: super.exprPart) {
//          b.append(part.toString()).append(" ");
//        }
      return b.toString();
    }
    
  }
  
  

  public static class AssignExpression extends Expression {
    /**Variable for assignments. It can contain a reference.
     * Hence the SimpleValue is used. 
     */
    SimpleValue leftVariable;
    
    @Override public String toString ( ) { 
      StringBuilder b = new StringBuilder(100);
      if(this.leftVariable !=null) { b.append(this.leftVariable.toString()).append(" = "); }
      if(super.exprPart !=null) {
        for(ExprPart part: super.exprPart) {
          b.append(part.toString()).append(" ");
        }
      }
      return b.toString();
    }
    
  }
  
  

  /**Class for Writing the Component Expression.*/
  public static class Expression extends JavaSrc_Base.Expression_Base {
  
    
    public static String dbgStopExprFile = "SpiMaster.java";
    
    public static int dbgStopLine1 = 738, dbgStopLine2 = 738;
    
    /**It is important to see which line/column was hit on {@link #dbgStopLine1} ..2 range */
    static int[] dbgRdLineColumn = new int[2];

    
    private boolean isPrepared;
    
    public Expression() {
      super();
      super.exprPart = new LinkedList<ExprPart>();
      Debugutil.stop();
    }
    
    public Expression(Expression src) {
      super();
      super.exprPart = new LinkedList<ExprPart>();
      super._srcFile_ = src._srcFile_;
      super._srcLine_ = src._srcLine_;
      super._srcColumn_= src._srcColumn_;
      Debugutil.stop();
    }
    
    public SimpleValue get_value() { 
      assert(super.exprPart.size()==1); 
      return super.exprPart.get(0).value; 
    }
    
    /**One instance describes one operator with its precedence.
     * Stored in {@link #opDescr}.
     */
    static class OpDescr {
      
      /**Operator character string
       * 
       */
      final String sOp; 
      
      /**The precedence. 1 is assignment, higher number is more strong binding. */
      final int preced;
      

      public OpDescr(String sOp, int preced) {
        this.sOp = sOp;
        this.preced = preced;
      } 
      
    }
    

    /**Association between operator and its precedence. 
     * Note: The order in the list is approximately the incidence of usage, to find it more fast.
     * 
     */
    public static final OpDescr[] opDescr = 
      { new OpDescr( "+"  , 12)
      , new OpDescr( "-"  , 12)
      , new OpDescr( "*"  , 13)
      , new OpDescr( "/"  , 13)
      , new OpDescr( "="  , 1)
      , new OpDescr( "&"  , 8)
      , new OpDescr( "|"  , 6)
      , new OpDescr( "&&" , 5)
      , new OpDescr( "||" , 4)
      , new OpDescr( ">>" , 11)
      , new OpDescr( "<<" , 11)
      , new OpDescr( "==" , 9)
      , new OpDescr( "!=" , 9)
      , new OpDescr( ">=" , 10)
      , new OpDescr( "<=" , 10)
      , new OpDescr( ">"  , 10)
      , new OpDescr( "<"  , 10)
      , new OpDescr( "?"  , 3)
      , new OpDescr( "^"  , 7)
      , new OpDescr( ">>>", 11)
      , new OpDescr( "+=" , 1)
      , new OpDescr( "-=" , 1)
      , new OpDescr( "*=" , 1)
      , new OpDescr( "/=" , 1)
      , new OpDescr( "&=" , 1)
      , new OpDescr( "|=" , 1)
      , new OpDescr( "<<=", 1)
      , new OpDescr( ">>=", 1)
      };

    /**Association between operator and its precedence for Java language. */
    public static Map<String, Integer> operatorPreced = new TreeMap<String, Integer>();
    { operatorPreced.put( "+"  , 12);
      operatorPreced.put( "-"  , 12);
      operatorPreced.put( "*"  , 13);
      operatorPreced.put( "/"  , 13);
      operatorPreced.put( "="  , 1);
      operatorPreced.put( "&"  , 8);
      operatorPreced.put( "|"  , 6);
      operatorPreced.put( "&&" , 5);
      operatorPreced.put( "||" , 4);
      operatorPreced.put( ">>" , 11);
      operatorPreced.put( "<<" , 11);
      operatorPreced.put( "==" , 9);
      operatorPreced.put( "!=" , 9);
      operatorPreced.put( ">=" , 10);
      operatorPreced.put( "<=" , 10);
      operatorPreced.put( ">"  , 10);
      operatorPreced.put( "<"  , 10);
      operatorPreced.put( "?"  , 3);
      operatorPreced.put( "^"  , 7);
      operatorPreced.put( ">>>", 11);
      operatorPreced.put( "+=" , 1);
      operatorPreced.put( "-=" , 1);
      operatorPreced.put( "*=" , 1);
      operatorPreced.put( "/=" , 1);
      operatorPreced.put( "&=" , 1);
      operatorPreced.put( "|=" , 1);
      operatorPreced.put( "<<=", 1);
      operatorPreced.put( ">>=", 1);
    }
    
    
    
    /**Helper class to save what should be stored for later usage.
     */
    static class StackOperator {

      JavaSrc.ExprPart part;
      int preced;

      public StackOperator(ExprPart part, int preced) {
        this.part = part;
        this.preced = preced;
      }
      
      @Override public String toString() { return this.part.toString(); }
    }
    
    public boolean isPrepared() {
      return this.isPrepared;
    }


    /**Prepare the simple parsed Java expression to convert to Revers Polish Notation form. 
     * @param log null or given for debug log
     * @return The expression in prepared RPN form.
     * @throws IOException
     */
    public void prep(Appendable log) throws IOException {
      if(this.isPrepared) { return; }
      boolean dbgStop = false;
      if(Expression.dbgStopExprFile !=null) { 
        String file = this.getSrcInfo(Expression.dbgRdLineColumn);  // TxSpe BlinkingLedCt ClockDivider BlinkingLed_Fpga
        if(file.contains(Expression.dbgStopExprFile) && Expression.dbgRdLineColumn[0] >= Expression.dbgStopLine1 && Expression.dbgRdLineColumn[0] <= Expression.dbgStopLine2) {
          Debugutil.stop();
          dbgStop = true;
      } }
      if(this.getSize_ExprPart()<=1) //return this;          //nothing to prepare, only one element. 
        Debugutil.stop();
      //JavaSrc.Expression dstExpr = new JavaSrc.Expression(this); 
      List<JavaSrc.ExprPart> partsNew = new LinkedList<JavaSrc.ExprPart>();
      prep(partsNew, log);
      this.exprPart = partsNew;                            //exchange also the parts.
      this.isPrepared = true;
      //return dstExpr;
    }
    
    
    
    
    
    /**Inner working operation, called recursively for all nested Expressions.
     * Nested Expressions are (expression) as {@link SimpleValue_Base#expression}
     * @param dstExpr will be consequently filled. 
     * The {@link #exprPart} instances of this will be reused. It means this is destroyed for further usage.
     * @param log
     * @throws IOException only if log is given
     */
    private void prep(List<JavaSrc.ExprPart> partsNew, Appendable log) throws IOException {
      if(this.isPrepared) return;
      if(log!=null) log.append("\n").append(this.toString());
      int nrParts = super.exprPart.size();
      ListIterator<ExprPart> iExprPart = super.exprPart.listIterator();
      //List<ExprPart> dstParts= null;
      
      StackOperator[] stackOp = new StackOperator[14];
      int ixStackOp = -1;
      if(nrParts ==1) {
        Debugutil.stop();
      }
      int preced = 0;
      int ixPart = 0;
      String sOpNext = null; //, sOpNext2 = null;
      int precedNext=0;
      while(iExprPart.hasNext()) {
        ExprPart part = iExprPart.next();        // process all source parts
        ixPart +=1;
        boolean bTrueFalseValue = !iExprPart.hasNext() && this.trueFalseValue !=null;   //trueFalseValue stored on expression
        if(bTrueFalseValue) {
          JavaSrc.ExprPartTrueFalse part2 = new JavaSrc.ExprPartTrueFalse(part);
          part2.trueExpr = new Expression(this.trueFalseValue.trueExpression);
          this.trueFalseValue.trueExpression.prep(part2.trueExpr.exprPart, log);
          this.trueFalseValue.trueExpression = null;
          part2.trueExpr.isPrepared = true;
          part2.falseExpr = new Expression(this.trueFalseValue.falseExpression);
          this.trueFalseValue.falseExpression.prep(part2.falseExpr.exprPart, log);
          this.trueFalseValue.falseExpression = null;
          part2.falseExpr.isPrepared = true;
          part = part2;
        }
        String sOpCurr = sOpNext;
        sOpNext = part.operator;
        if(sOpNext !=null && sOpNext.equals("*"))
          Debugutil.stop();
        part.operator = sOpCurr;
        precedNext=0;
        //String op = part.operator;    // get the precedence of the next coming operation with this part.
        String op = sOpNext;
        int found = 2;
        if(op == null) { precedNext = 0; found -=1; }
        if(sOpCurr == null) { preced = 0; found -=1; }
        for(OpDescr descr : opDescr) {
          if(op !=null && descr.sOp.equals(op)) {
            precedNext = descr.preced;
            found -=1;
          }
          if(sOpCurr !=null && descr.sOp.equals(sOpCurr)) {
            preced = descr.preced;
            found -=1;
          }
          if(found ==0) { break; }
        }                         // last element without operator, higher than assign last element without operator
        //if(preced ==0) { preced = 1; }         // it is also the first element, no operations.
        if(log!=null) log.append("\n\n").append(part.toString()).append(" ").append(sOpNext).append(" preced " + preced).append("->" + precedNext);
        //assert(precedNext >0);
        if(part.toString().startsWith("e"))
          Debugutil.stop();
        if(part.value.expression !=null) {                 // ==== nested expression, parenthesis
          //The nested expression creates one level on stack. Hence it should be notified on the stack:
          part.bStackInstance = true;                      // use this part as operand part, no more used.
          stackOp[++ixStackOp] = new StackOperator(part, preced); //(part.operator, sUnary, preced);
          if(log!=null) log.append("\n inner Expr) ");
          for(int ix=0; ix <= ixStackOp; ++ix) { if(log!=null) log.append(stackOp[ix].toString()).append(":"); }
          Expression innerExpr = part.value.expression;  
          String sUnary = part.value.unaryOperator;
          part.value = null;                   //dstExprexpression value is already evaluated and stored in dstExpr.exprPart
          innerExpr.prep(partsNew, log);
          if(sUnary !=null)  {                             // it is the unary operation for the nested expression
            ExprPart partUnary = new ExprPart();
            partUnary.sUnaryOp = sUnary;
            partUnary.operator = "@";
            partsNew.add(partUnary);
          }
          Debugutil.stop();
        }
        if(part.value != null) {                 // it is null on a nested expression before which is not an assignment
          if(precedNext > preced) {               //==== higher precedence: Save only the operator in stack
            String sUnary = part.value !=null ? part.value.unaryOperator : null;
            ExprPart partStack = new ExprPart();
            partStack.operator = part.operator; //continue with the stored operation before the finished level
            partStack.sUnaryOp = part.sUnaryOp;
            partStack.bStackInstance = true;
            stackOp[++ixStackOp] = new StackOperator(partStack, preced); //.operator, sUnary, preced);  // ...to apply later.
            part.operator = "@";                 //set operator currently as "store in stack"
            partsNew.add(part);
            if(log!=null) log.append("higher Preced");
          }
          else { //if(precedNew < preced) {          // follow lesser precedense, then close the higher expression.
//            part.operator = sOpNext1;            // add this as last one with given operator
            boolean isAdded = false;
            while(ixStackOp > 0 && precedNext <= stackOp[ixStackOp].preced) {  // let one level in stack, hence >0
              if(!isAdded && stackOp[ixStackOp].preced < preced) {
                partsNew.add(part);
                isAdded = true;
              }
              ExprPart partStack = stackOp[ixStackOp].part; //new ExprPart();
              partStack.bStackInstance = true;
              stackOp[ixStackOp--] = null;
              //partStack.operator = sOpNext;
              partStack.value = null;                   // no value, add the stack content on opertion.
              partsNew.add(partStack);                 // 
            }
            if(!isAdded) {
              partsNew.add(part);
            }
            if(log!=null) log.append(" <= preced");
          }
          preced = precedNext;
          if(log!=null) log.append("\n");
          for(int ix=0; ix <= ixStackOp; ++ix) { if(log!=null) log.append(stackOp[ix].toString()).append(":"); }
          if(log!=null) log.append("\n").append(partsNew.toString());
          Debugutil.stop();
        }
      }
      while(ixStackOp > 0 ) {  // let one level in stack, hence >0
        ExprPart partStack = stackOp[ixStackOp].part;  //new ExprPart();
        stackOp[ixStackOp--] = null;
        assert(partStack.value ==null);
        partsNew.add(partStack);                 // 
      }

      this.isPrepared = true;
      if(log!=null) log.append("\n").append(partsNew.toString());
    }
    
    
    
    /**A normal assign expression with simple assignment in first level.
     * <pre>
     * a = b*c;
     * </pre>
     * It does not detect any inner assignment such as <code>if ( ( a = b*C) >5) { ....
     * @return true if it is a simple assign expression.
     */
    public boolean isAssignExpr ( ) { 
      if(!this.isPrepared) {
        try { prep(null);
        } catch (IOException e) { throw new RuntimeException("unexpected"); }
      }
      for(JavaSrc.ExprPart part : super.exprPart) {
        if(part.operator !=null && part.operator.equals("=")) { return true; }
      }
      return false; 
    }
    
    @Override public String toString() {
      return showInfo(); // + showSrcInfo();
    }
    
    public String showInfo ( ) {
      StringBuilder b = new StringBuilder(200);
      for(ExprPart part: super.exprPart) {
        part.toString(b); b.append("; ");
      }
      return b.toString();
    }
    
  } // class Expression



  /**Class for Writing the Component Java4CAnnotationClass.*/
  public static class Java4CAnnotationClass extends JavaSrc_Base.Java4CAnnotationClass_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Java4CAnnotationMethod.*/
  public static class Java4CAnnotationMethod extends JavaSrc_Base.Java4CAnnotationMethod_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Java4CAnnotationType.*/
  public static class Java4CAnnotationType extends JavaSrc_Base.Java4CAnnotationType_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Java4CAnnotationVariable.*/
  public static class Java4CAnnotationVariable extends JavaSrc_Base.Java4CAnnotationVariable_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component ModifierClass.*/
  public static class ModifierClass extends JavaSrc_Base.ModifierClass_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component ModifierMethod.*/
  public static class ModifierMethod extends JavaSrc_Base.ModifierMethod_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component ModifierVariable.*/
  public static class ModifierVariable extends JavaSrc_Base.ModifierVariable_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component TrueFalseValue.*/
  public static class TrueFalseValue extends JavaSrc_Base.TrueFalseValue_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component actualArguments.*/
  public static class ActualArguments extends JavaSrc_Base.ActualArguments_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component annotation.*/
  public static class Annotation extends JavaSrc_Base.Annotation_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component annotationDefinition.*/
  public static class AnnotationDefinition extends JavaSrc_Base.AnnotationDefinition_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component argument.*/
  public static class Argument extends JavaSrc_Base.Argument_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component argumentList.*/
  public static class ArgumentList extends JavaSrc_Base.ArgumentList_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component arrayElementAccess.*/
  public static class ArrayElementAccess extends JavaSrc_Base.ArrayElementAccess_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component caseExpr.*/
  public static class CaseExpr extends JavaSrc_Base.CaseExpr_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component catchBlock.*/
  public static class CatchBlock extends JavaSrc_Base.CatchBlock_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component classContent.*/
  public static class ClassContent extends JavaSrc_Base.ClassContent_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component classDefinition.*/
  public static class ClassDefinition extends JavaSrc_Base.ClassDefinition_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return super.classident;
    }
  
  }




  /**Class for Writing the Component classpath.*/
  public static class Classpath extends JavaSrc_Base.Classpath_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }



  /**Class for Writing the Component constNumber.*/
  public static class ConstNumber extends JavaSrc_Base.ConstNumber_Base implements SetSrcInfo_ifc {
  
  
    @Override  public void setSrcInfo ( String src) {
      super.sNumber = src;
    }
  
    public String get_sNumber ( ) {return this.sNumber; }
    
    @Override public String toString ( ) { 
      if(super.booleanConst !=null) {
        return super.booleanConst;
      }
      else if(super.hexNumber !=0) {
        return "0x" + Integer.toHexString(super.hexNumber);
      }
      else if(sNumber !=null ) {
        return sNumber;
      }
      else return super.sNumber;
    }

  }




  /**Class for Writing the Component constArray.*/
  public static class ConstArray extends JavaSrc_Base.ConstArray_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }



  /**A common interface for {@link ConstructorDefinition} 
   * and all {@link MethodDefinition} via {@link StatementBlock}
   */
  public interface GetStatement_ifc {
    Iterable<JavaSrc.Statement> get_statement();
    
    int getSize_statement();
  }
  

  /**Class for Writing the Component constructorDefinition.*/
  public static class ConstructorDefinition extends JavaSrc_Base.ConstructorDefinition_Base implements GetStatement_ifc {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component description.*/
  public static class Description extends JavaSrc_Base.Description_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component dowhile_statement.*/
  public static class Dowhile_statement extends JavaSrc_Base.Dowhile_statement_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component enumDefinition.*/
  public static class EnumDefinition extends JavaSrc_Base.EnumDefinition_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component envIdent.*/
  public static class EnvIdent extends JavaSrc_Base.EnvIdent_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component forElement_statement.*/
  public static class ForElement_statement extends JavaSrc_Base.ForElement_statement_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component for_statement.*/
  public static class For_statement extends JavaSrc_Base.For_statement_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component generic.*/
  public static class Generic extends JavaSrc_Base.Generic_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component if_statement.*/
  public static class If_statement extends JavaSrc_Base.If_statement_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component importStatement.*/
  public static class ImportStatement extends JavaSrc_Base.ImportStatement_Base {
  
  
    /**Returns the path separated with slash (not with dot), but without extension .java
     * @return
     */
    public String getPath() {
      String ret = "";
      for(String pkg: super.packagePath) { ret += pkg + "/"; }
      return ret + super.class___;
    }
  
  
    @Override public String toString ( ) { 
      return super.packagePath + super.class___;
    }
  
  }




  /**Class for Writing the Component importpath.*/
  public static class Importpath extends JavaSrc_Base.Importpath_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component interfaceDefinition.*/
  public static class InterfaceDefinition extends JavaSrc_Base.InterfaceDefinition_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component java2cTag.*/
  public static class Java2cTag extends JavaSrc_Base.Java2cTag_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component java2cTagParam.*/
  public static class Java2cTagParam extends JavaSrc_Base.Java2cTagParam_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component maybeReferencedVariable.*/
  public static class MaybeReferencedVariable extends JavaSrc_Base.MaybeReferencedVariable_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component methodDefinition.*/
  public static class MethodDefinition extends JavaSrc_Base.MethodDefinition_Base  {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component newArray.*/
  public static class NewArray extends JavaSrc_Base.NewArray_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component newObject.*/
  public static class NewObject extends JavaSrc_Base.NewObject_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component nonArrayType.*/
  public static class NonArrayType extends JavaSrc_Base.NonArrayType_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component operator.*/
  public static class Operator extends JavaSrc_Base.Operator_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component paramDescription.*/
  public static class ParamDescription extends JavaSrc_Base.ParamDescription_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component paramInDescription.*/
  public static class ParamInDescription extends JavaSrc_Base.ParamInDescription_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component reference.*/
  public static class Reference extends JavaSrc_Base.Reference_Base {
  
  
    /**Returns the name of a simple variable as first reference
     * or null if an operation or (expression) or (new Instance...) is used as reference.
     * This is especially proper if a determined style guide for sources exists,
     * which uses as first simple variable. 
     * If the reference is a chain of variable, also only the first variable is returned.
     * Use getRefVariableChain() to get a chain for such cases. 
     * @return
     */
    public String getSimpleRefVariable ( ) {
      if(super.referenceAssociation !=null) {
        return super.referenceAssociation.variableName;
      } else if((super.isThis!=null || super.isSuper!=null) && super.reference !=null) {
        return super.reference.getSimpleRefVariable();
      }
      else return null;
    }
  
    public String getRefVariableChain ( ) {
      
      return null;  //TODO if necessary
    }
  
    @Override public String toString ( ) { 
      return showInfo() + showSrcInfo();
    }
  
    public String showInfo ( ) { 
      StringBuilder bu = null;
      if(super.reference !=null) {
        bu = new StringBuilder(100); 
        bu.append(super.reference.showInfo()).append(".");
        if(super.isThis !=null) { bu.insert(0, "this."); }
        if(super.isSuper !=null) { bu.insert(0, "super."); }
        if(super.expression !=null) { bu.insert(0, super.expression.showInfo()+"."); }
        else if(super.referenceAssociation !=null) { bu.insert(0, super.referenceAssociation.showInfo()+"."); }
        else { bu.insert(0,"??ref"); }
        return bu.toString();
      }
      else {
        if(super.expression !=null) return super.expression.showInfo() + ".";
        else if(super.isThis !=null) return "this.";
        else if(super.isSuper !=null) return "super.";
        else if(super.referenceAssociation !=null) { return super.referenceAssociation.showInfo() + "."; }
        else return "TODO reference";
      }
    }
    }




  /**Class for Writing the Component rententionpolicy.*/
  public static class Rententionpolicy extends JavaSrc_Base.Rententionpolicy_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component returnDescription.*/
  public static class ReturnDescription extends JavaSrc_Base.ReturnDescription_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component simpleMethodCall.*/
  public static class SimpleMethodCall extends JavaSrc_Base.SimpleMethodCall_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return super.methodName;
    }
  
  }




  /**Class for Writing the Component simpleValue.*/
  public static class SimpleValue extends JavaSrc_Base.SimpleValue_Base {
  
  
    /**Access to parse result.*/
    public int get_hexNumber() { return super.constNumber ==null ? 0 : super.constNumber.hexNumber; }
    
    
    
    
    /**Access to parse result.*/
    public int get_hexNumberNegative() { return super.constNumber ==null ? 0 : super.constNumber.hexNumberNegative; }
    
    
    
    
    /**Access to parse result.*/
    public String get_booleanConst() { return super.constNumber ==null ? null : super.constNumber.booleanConst; }
    
    
    
    
    /**Access to parse result.*/
    public int get_intNumber() { return super.constNumber ==null ? 0 : super.constNumber.intNumber; }
    
    
    
    
    /**Access to parse result.*/
    public String get_valueFormat() { return super.constNumber ==null ? "" : super.constNumber.valueFormat; }
    
    
    
    
    /**Access to parse result.*/
    public float get_floatNumber() { return super.constNumber ==null ? 0 : super.constNumber.floatNumber; }
    
    
    
    
    /**Access to parse result.*/
    public float get_doubleNumber() { return super.constNumber ==null ? 0 : super.constNumber.doubleNumber; }

  
  
    @Override public String toString ( ) { 
      StringBuilder b = new StringBuilder(100);
      if(super.unaryOperator !=null) { b.append(super.unaryOperator); }
      if(super.reference !=null) { b.append(super.reference.showInfo());}
      if(super.simpleVariable !=null) { 
        b.append(super.simpleVariable.showInfo());
      }  
      else if(super.expression !=null) {
        b.append( "(").append(super.get_Expression().showInfo()).append(")");
      }
      else if(super.simpleMethodCall !=null) {
        b.append(super.simpleMethodCall.methodName).append("(...)");
      }
      else if(super.constNumber !=null) {
        b.append(super.constNumber.toString());
      }
      else if(super.simpleStringLiteral !=null) {
        b.append('\"').append(super.simpleStringLiteral).append('\"');
      }
      else if(super.simpleCharLiteral !=null) {
        b.append('\'').append(super.simpleCharLiteral).append('\'');
      }
//      else if(super.booleanConst !=null) {
//        b.append(super.booleanConst);
//      }
      else {
        b.append("TODO SimpleValue.toString()");
      }
      //b.append(showSrcInfo());
      return b.toString();
    }
  
  }




  /**Class for Writing the Component simpleVariable.*/
  public static class SimpleVariable extends JavaSrc_Base.SimpleVariable_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return super.variableName + showSrcInfo();
    }
    
    public String showInfo ( ) { 
      return super.variableName;
    }
  }




  /**Class for Writing the Component statement.*/
  public static class Statement extends JavaSrc_Base.Statement_Base {
  
  
    /**Replaces the evaluated Expression which is an assignment with the better instance
     * of the AssignExpression. 
     * @param expr
     */
    public void set_AssignExpression(Expression expr) {
      super.expression = expr;
    }
  
    
    public boolean isAssignExpr ( ) { return super.expression !=null && super.expression.isAssignExpr(); }
  
    @Override public String toString ( ) { 
      if(super.expression !=null) return super.expression.toString();
      else if(super.if_statement !=null) return "if( " + super.if_statement.expression.toString();
      else return "TODO toString";
    }
  
  }




  /**Class for Writing the Component statementBlock.*/
  public static class StatementBlock extends JavaSrc_Base.StatementBlock_Base implements GetStatement_ifc {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component statementsOrDefinition.*/
  public static class StatementsOrDefinition extends JavaSrc_Base.StatementsOrDefinition_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component superCall.*/
  public static class SuperCall extends JavaSrc_Base.SuperCall_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component switch_statement.*/
  public static class Switch_statement extends JavaSrc_Base.Switch_statement_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component test_description.*/
  public static class Test_description extends JavaSrc_Base.Test_description_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component throwsDeclaration.*/
  public static class ThrowsDeclaration extends JavaSrc_Base.ThrowsDeclaration_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component try_statement.*/
  public static class Try_statement extends JavaSrc_Base.Try_statement_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component type.*/
  public static class Type extends JavaSrc_Base.Type_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return super.name;
    }
  
  }




  /**Class for Writing the Component typeIdent.*/
  public static class TypeIdent extends JavaSrc_Base.TypeIdent_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component unaryOperator.*/
  public static class UnaryOperator extends JavaSrc_Base.UnaryOperator_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component variableDefinition.*/
  public static class VariableDefinition extends JavaSrc_Base.VariableDefinition_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component variableInstance.*/
  public static class VariableInstance extends JavaSrc_Base.VariableInstance_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return super.variableName;
    }
  
  }




  /**Class for Writing the Component while_statement.*/
  public static class While_statement extends JavaSrc_Base.While_statement_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }







  /**Class for Writing the Component enumElement.*/
  public static class EnumElement extends JavaSrc_Base.EnumElement_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }


}

